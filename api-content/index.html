{"posts":[{"title":"小学二年级也能听懂的数位dp基础（","content":"数位dp是什么 字面意思 数位dp往往都是一样的题型，给定一个闭区间 [l,r][l,r][l,r]，让你求这个区间中满足某种条件的数的总数 感觉很有套路 例题 P2657 [SCOI2009] windy 数 做法： 这大概是数位dp模板题或者入门题，这种题还是挺套路的 我们设dp[i][j]为长度i中最高位是j的windy数的个数 dp[i][j]=∑k=09[abs(j−k)&gt;=2]\\sum\\limits_{k=0}^{9}[abs(j-k)&gt;=2]k=0∑9​[abs(j−k)&gt;=2] 每一步的转移都是前一位的和转移过来的 先初始化所有的dp[i][j] 接着算[a,b][a,b][a,b]区间的所有windy数 #define MAXN 20 int a[MAXN],dp[MAXN][MAXN],n,m; void init(){ //初始化 for(int i=0;i&lt;=9;i++)dp[1][i]=1; //要注意0,1,2,3,4...9都属于windy数 for(int i=2;i&lt;=10;i++){ //枚举从第二位开始的每一位 for(int j=0;j&lt;=9;j++){ //第i位上的数 for(int k=0;k&lt;=9;k++){ //从上一位的数转移过来 if(fabs(j-k)&gt;=2)dp[i][j]+=dp[i-1][k]; //状态转移 } } } } int work(int x){ //开始计算 int len=0; ll ans=0; memset(a,0,sizeof(a)); while(x&gt;0){ a[++len]=x%10; x/=10; } //算位数，用a数组存每一位，要注意这样存的是倒着存的，len位是最高位 // 1. 位数小于len，则无需考虑与x的大小关系 for(int i=1;i&lt;len;i++){ //1~len-1位 for(int j=1;j&lt;=9;j++){ //最高位只能取1~9 ans+=dp[i][j]; } } // 2.len位，最高位小于原数最高位，也不用考虑与x的大小关系 for(int i=1;i&lt;a[len];i++){ ans+=dp[len][i]; } // 3. len位，最高位等于原数最高位，较为复杂，需要考虑与x的大小关系 for(int i=len-1;i&gt;=1;i--){ //处理 1~len-1位 for(int j=0;j&lt;=a[i]-1;j++){ //第i位为j if(abs(j-a[i+1])&gt;=2)ans+=dp[i][j]; //计算 } if(abs(a[i+1]-a[i])&lt;2)break; //小于2直接跳过 } return ans; } int main(){ cin&gt;&gt;n&gt;&gt;m; init(); cout&lt;&lt;work(m+1)-work(n)&lt;&lt;endl; /*这里有的人会说为什么不是work(m)-work(n-1) 那是因为每次算work如果自己是windy数，但不会带上自己 所以需要计算work(x+1)，work(m+1)-work(n-1+1)，小细节需要注意一下 如果写work(m)-work(n-1)只能得90分 */ return 0; } ","link":"https://Oak-limy.github.io/post/xiao-xue-er-nian-ji-ye-neng-ting-dong-de-shu-wei-dp-ji-chu/"},{"title":"Codeforces Round 636 (Div. 3) F题 题解","content":"题意 给你一个长度为 nnn 的排列 aaa，但你不知道这个排列具体长什么样，再给出 n−1n-1n−1 个子排列，每个排列的元素为 [al,al+1,…,ar][a_l,a_l+1,\\dots,a_r][al​,al​+1,…,ar​]，rrr 代表从 222 ~ nnn 的数字，这 n−1n-1n−1 个排列中每个数必将出现一次，现在让你倒推回去，输出一种可能方案的 aaa。题目保证肯定有一种可行方案。 首先要了解几个重要的性质： 如果一个数出现在所有子排列中出现两次及以上，则这个数肯定不是原排列里的最后一个数 如果有一个数出现次数只有一次，则它可能是最后一个也可能是第一个数 知道这么多差不多就可以做这道题了（在这个解法中好像没怎么体现出 思路 我们考虑从前往后构造原排列 如果知道了第一位的数，那么就可以通过枚举求出第二位置的，以此类推。 const ll MAXN=210; ll t,n; ll a[MAXN][MAXN],pos[MAXN],ans[MAXN]; bool ok(){ for(int now=2;now&lt;=n;now++){//从第二位开始枚举 for(int i=1;i&lt;n;i++){//枚举子排序 ll r=a[i][0],x=-1;//r为当前子排序的k for(int k=1;k&lt;=a[i][0];k++){ ll b=a[i][k];//当前子排序的数 if(!pos[b])x=b; else if(pos[b]&gt;=now-a[i][0]+1)r--;//要在当前子排序中 } if(r==1&amp;&amp;x!=-1){//r-1个数都用掉了 ans[now]=x; pos[x]=now; break; } } if(ans[now]==0)return false; } return true; } int main(){ cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; for(int i=1;i&lt;n;i++){ cin&gt;&gt;a[i][0];//输进来的k for(int j=1;j&lt;=a[i][0];j++)cin&gt;&gt;a[i][j]; } for(int i=1;i&lt;=n;i++){//第一位1~n枚举 for(int j=1;j&lt;=n;j++){ pos[j]=0;ans[j]=0;//初始化 } ans[1]=i;//枚举的第一位，所以第一位设i pos[i]=1;//i的位置为1 if(ok())break;//可行方案 } for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;' '; cout&lt;&lt;endl; } } 参考： 1 2 ","link":"https://Oak-limy.github.io/post/codeforces-round-636-div-3-f-ti-ti-jie/"},{"title":"Codeforces Round 634 (Div. 3) F题 题解","content":"题意 给你一个 n×mn\\times mn×m 的矩阵，每个格子上有颜色，000 代表黑，111 代表白。每个格子上还有方向，在这个格子上的机器人会向格子方向的方向走，并且题目保证机器人不会走出矩阵。 你需要完成以下几个任务： 在格子上摆放尽可能多的机器人，他们同时开始无尽地运动，并且任何时刻都不能有两个机器人在同一个格子 首先最大化机器人的个数，如果有多种方案机器人个数相等，再最大化初始时摆在黑格内的机器人 首先，题目中提到的无尽，则代表每个机器人走的路线都是循环的。 对于每个机器人，它走的路径最长也就是 n∗mn*mn∗m。我们考虑在 n∗mn * mn∗m 步内机器人的相遇情况 如果有两个机器人在不在同一个循环里，毫不相干。则它们肯定不会相遇 如果有两个机器人在同一个循环里，并且在 n×mn\\times mn×m 的步数里没有相遇，则他们也会以这样的节奏继续走下去，也不会相遇；反之如果相遇了的话，他们会在同样的格子里一直走下去。 所以我们想判断两个机器人是否会相遇，只需要看在 n×mn\\times mn×m 的步数里两个机器人是否在一起就行了 我们用一维 colorcolorcolor 数组表示每个位置的颜色，用 whitewhitewhite 和 blackblackblack 数组表示机器人的初始位置的颜色 对于走 n×mn\\times mn×m ，我们可以使用倍增，最后统计答案。 const ll MAXN=1e6+10; ll a[MAXN],color[MAXN],black[MAXN],white[MAXN],mult[21][MAXN]; ll t,n,m; char ch[MAXN]; int main(){ cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;ch+1; for(int j=1;j&lt;=m;j++){ if(ch[j]=='0')color[(i-1)*m+j]=0;//黑色 else color[(i-1)*m+j]=1;//白色 } } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;(ch+1); for(int j=1;j&lt;=m;j++){ ll pos=(i-1)*m+j; //在数组上的位置 if(ch[j]=='U')mult[0][pos]=pos-m;//上 if(ch[j]=='D')mult[0][pos]=pos+m;//下 if(ch[j]=='L')mult[0][pos]=pos-1;//左 if(ch[j]=='R')mult[0][pos]=pos+1;//右 } } ll matrix=n*m;//最大路径 for(int i=1;i&lt;=20;i++){ for(int j=1;j&lt;=matrix;j++){ mult[i][j]=mult[i-1][mult[i-1][j]];//倍增 } } for(int j=1;j&lt;=matrix;j++){ ll pos=j; for(int i=20;i;i--){ if((1&lt;&lt;i)&amp;matrix)pos=mult[i][pos]; } if(color[j])white[pos]=1;//是白 else black[pos]=1;//是黑 } ll res=0,bla=0; for(int i=1;i&lt;=matrix;i++){ if(black[i]){ res++; bla++;//是黑色的++ black[i]=0; white[i]=0; } else if(white[i]){ res++; black[i]=0; white[i]=0; } } cout&lt;&lt;res&lt;&lt;' '&lt;&lt;bla&lt;&lt;endl; } return 0; } 第一次在自己博客里发题解，感觉就是给菜鸡一样的自己看的，以后会继续尝试div3f题的qaq/kk 还是希望大佬能支持/kel ","link":"https://Oak-limy.github.io/post/CF1335F/"},{"title":"任务计划","content":"训练计划： Atcoder dp contest\\quad(题解)\\quad(7 / 26) Div. 3难度图论树论题练手(自制题单)\\quad(3 / ∞) 补之前打过的CF的题 补刷历年 NOIP-TG 的题 CF Div2 D &amp; E题 算法学习： **各种dp（（（ ** 数位dp 期望dp 树形dp 概率dp 斜率优化dp 网络流 字符串(SA &amp; SAM &amp; KMP) FFT &amp; NTT 数学 毒瘤数据结构(平衡树 &amp; 主席树 &amp; splay &amp; Treap) 树链剖分 图论() 算法复习： 线段树 模拟（ 学习中： dp 树链剖分 数据结构 老师教的好，同学学的会👍： 博 弈 论 做题计划： 【动态规划】普及~省选的dp题\\quad (12 / 50) 莫比乌斯反演（函数）练习题单\\quad(2 / 17) codeforces 2200左右的DS题 \\quad(0/50) ","link":"https://Oak-limy.github.io/post/ren-wu-ji-hua/"},{"title":"个人常用模板","content":"**常规模板 ** #include &lt;bits/stdc++.h&gt; #define endl '\\n' #define fast ios::sync_with_stdio(0),cin.tie(0),cout.tie(0) #define zy -2147382637 #define bql 2147483647 #define ll long long #define ull unsigned long long #define ld long double #define il inline #define sz(x) x.size() #define maxn 100010 #define rp(i, l, r) for (int i = l; i &lt;= r; i++) #define rb(i, r, l) for (int i = r; i &gt;= l; i--) #define fi first #define se second #define pb push_back #define mp make_pair using namespace std; ll max(ll a,ll b){if(a&gt;b)return a;else return b;} ll min(ll a,ll b){if(a&lt;b)return a;else return b;} ll lowbit(ll x){return x&amp;(-x);} ll prime(ll x){ if(x&lt;=1)return false; for(int i=2;i&lt;=int(sqrt(x));i++){ if(x%i==0)return false; }return true; }bool cmp(ll a,ll b){return a&gt;b;} ll gcd(ll a,ll b){ll r;while(b&gt;0){r=a%b;a=b;b=r;}return a;} ll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;} inline int readint() { char c = getchar(); int w = 1; int x = 0; while (!isdigit(c)) (c == '-') &amp;&amp; (w = -w), c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = getchar(); x *= w; return x; } inline ll readll() { char c = getchar(); ll w = 1; ll x = 0; while (!isdigit(c)) (c == '-') &amp;&amp; (w = -w), c = getchar(); while (isdigit(c)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ '0'), c = getchar(); x *= w; return x; } void fl(string name){ freopen((name+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin); freopen((name+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout); } const int dx[8] = {-1, 1, 0, 0, -1, 1, -1, 1}, dy[8] = {0, 0, -1, 1, -1, -1, 1, 1}; int main(){ } /* stuff to remember * int overflow, array bounds * special cases (n=1? n=0?) * do something instead of nothing and stay organized * USE STATIC ARRAYS * DEFINING ARRAYS BEFORE main() * DO NOT DEFINE ARRAYS IN main() * USE INT INSTEAD OF LL,NOTICE THE MLE */ ","link":"https://Oak-limy.github.io/post/ge-ren-chang-yong-mo-ban/"},{"title":"我的个人博客开始施工了！！！","content":"尽管知道就算搞出来了也没人看/kk emmemmemm 尽管很弱，但是基本的东西总是要有的（ ","link":"https://Oak-limy.github.io/post/wo-de-ge-ren-you-xiang-kai-shi-shi-gong-liao/"}]}